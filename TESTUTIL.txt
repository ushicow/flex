* TEST UTILITY
* COPYRIGHT 1980 BY TECHNICAL SYSTEMS CONSULTANTS, INC.
* TESTS SINGLE SECTOR READ AND WRITE ROUTINES.
* PROGRAM PROMPTS USER FOR FUNCTIONS (F?) TO WHICH THE
* USER CAN RESPOND 'R' (READ) OR 'W' (WRITE). THEN IN
* PROMPTS FOR SINGLE DIGIT DRIVE NUMBER (D?), TWO DIGIT
* HEX TRACK NUMBER (T?) AND TWO DIGIT HEX SECTOR
* NUMBER (S?). AFTER PERFORMING THE FUNCTION. TEST
* REPEATS THE PROMPTING FOR ANOTHER FUNCTION.
*
* ASSUMES THE CONSOLE I/O PACKAGE DRIVERS ARE RESIDENT.
* BEGIN EXECUTION BY JUMPING TO $0100.
*
*
* EQUATES
*
INCH	.EQ	$D3FB
OUTCH	.EQ	$D3F9
TINIT	.EQ	$D3F5
MONITR	.EQ	$D3F3
STACK	.EQ	$C07F
FCB	.EQ	$C840
BUFFER	.EQ	$1000
READ	.EQ	$DE00
WRITE	.EQ	$DE03
DRIVE	.EQ	$DE0C
*
* TEMPORARY STORAGE
*
COMMND	.EQ	$20
TRACK	.EQ	$21
SECTOR	.EQ	$22
*
* START OF PROGRAM
	.OR $0100
	.TA $8100
	.TF TESTUTIL.8100
*
TEST	LDS #STACK	SETUP STACK
	JSR (TINIT)	INITIALIZE TERMINAL
*
* GET COMMAND
*
TEST1	LDS #STACK	RESET STACK
	BSR PCRLF
	LDA #'F		PROMPT FOR FUNCTION
	BSR PROMPT
	BSR INPUT	GET RESPONSE
	CMPA #'R	READ COMMAND?
	BEQ TEST2
	CMPA #'W	WRITE COMMAND?
	BEQ TEST2
	JMP (MONITR)	EXIT THE PROGRAM
TEST2	STA COMMND	SAVE COMMAND
	LDA #'D		PROMPT FOR DRIVE
	BSR PROMPT
	JSR INHEX	GET RESPONSE
	CMPA #4		ENSURE 0 TO 3
	BHS TEST1
	STA FCB+3	SAVE IT
	LDA #'T		PROMPT FOR TRACK
	BSR HPRMPT	GET HEX PROMPT
	STA TRACK
	LDA #'S		PROMPT FOR SECTOR
	BSR HPRMPT	GET HEX RESPONSE
	STA SECTOR	SAVE IT
	BSR PCRLF	DO LINE FEED
*
* GOT COMMAND, NOW DO IT
	LDA COMMND	GET COMMAND
	CMPA #'W	A WRITE COMMAND?
	BNE DOREAD	IF NOT, ITS A READ
	BSR SELECT	SELECT DRIVE
	LDX #BUFFER	POINT TO BUFFER
	LDD TRACK	POINT TO TRACK & SECTOR
	JSR WRITE	WRITE THE DATA
	BNE ERROR
	BSR PCRLF
	LDA #'O		PRINT OK
	BSR OUTPUT
	LDA #'K
	BSR OUTPUT
	BRA TEST1	DO AGAIN
*
* PROMPT ROUTINES
*
PROMPT	BSR PCRLF	DO LINE FEED
	BSR OUTPUT	OUTPUT PROMPT LETTER
	BRA QUEST	PRINT QUESTION MARK
HPRMPT	BSR PROMPT	DO PROMPT
	BRA INBYTE	GET HEX BYTE
*
* CARRIAGE RETURN LINE FEED ROUTINE
*
PCRLF	PSHS A		SAVE A
	LDA #$0D	RETURN
	BSR OUTPUT
	LDA #$0A	LINE FEED
	BSR OUTPUT
	PULS A		RESTORE A
RET	RTS
*
* I/O ROUTINES
*
INPUT	JMP (INCH)
QUEST	LDA #'?
OUTPUT	JMP (OUTCH)
*
* DRIVE SELECT ROUTINE
*
SELECT	LDX #FCB
	JSR DRIVE
	BEQ RET		RETURN IF NO ERROR
*
* DRIVER ERROR
*
ERROR	BSR PCRLF
	LDA #'E
	BSR OUTPUT
	LDA #'=
	BSR OUTPUT
	TFR B,A		GET ERROR CODE
	BSR OUTHEX
	LBRA TEST1	START OVER
*
* DO SINGLE SECTOR READ
DOREAD	BSR SELECT	SELECT DRIVE
	LDX #BUFFER	POINT TO BUFFER
	LDD TRACK	POINT TO TRACK & SECTOR
	JSR READ	READ THE DATA
	BNE ERROR
*
* DUMP DATA TO CONSOLE
*
	LDX #BUFFER
	LDA #16		NO OF LINE
DUMP1	PSHS A		SAVE NO FO LINES
	BSR PCRLF
	LDB #16		NO FO BYTES
DUMP2	LDA ,X+		GET A BYTE
	BSR OUTHEX	OUTPUT IT
	DECB		DONE WITH LINES?
	BNE DUMP2
	PULS A		GET NO FO LINES
	DECA		DONE WITH DUMP
	BNE DUMP1	LOOP IF NOT
	LBRA TEST1	GET NEXT COMMAND
*
* INPUT HEX BYTE ROUTINE
INBYTE	BSR INHEX
	ASLA
	ASLA
	ASLA
	ASLA
	PSHS A
	BSR INHEX
	ADDA ,S+
RETN	RTS
*
INHEX	BSR INPUT
	SUBA #$47
	BPL INERR
	ADDA #6
	BPL INH2
	ADDA #7
	BPL INERR
INH2	ADDA #10
	BPL RETN
INERR	BSR QUEST	PRINT A QUESTION MARK
	LBRA TEST1	GO START OVER
*
* OUTPUT HEX BYTE (FOLLOWED BY SPACE)
*
OUTHEX	PSHS A
	LSRA
	LSRA
	LSRA
	LSRA
	BSR OUTHR
	PULS A
	BSR OUTHR
	LDA #$20
	BRA OUTPUT
OUTHR	ANDA #$0F
	ADDA #$90
	DAA
	ADCA #$40
	DAA
	LBRA OUTPUT
*
	.EN
